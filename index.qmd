---
title: Modeling Disability-Adjusted Life Years for Policy and Decision Analysis
subtitle: A Tutorial
author:
  - name: John A. Graves
    orcid: 0000-0002-8954-8202
    corresponding: true
    roles: []    
    email: john.graves@vanderbilt.edu
    affiliations:
      - Vanderbilt University      
      - Vanderbilt University Medical Center       
  - name: Jinyi Zhu
    orcid: 0000-0001-8169-5956
    corresponding: false
    roles: []
    affiliations:
      - Vanderbilt University
      - Vanderbilt University Medical Center       
  - name: Hannah Peterson
    corresponding: false
    roles: []
    affiliations:
      - Vanderbilt University Medical Center    
  - name: Shawn Garbett
    corresponding: false
    roles: []
    affiliations:
      - Vanderbilt University Medical Center        
  - name: Ashley Leech
    orcid: 0000-0001-6795-929X
    corresponding: false
    roles: []
    affiliations:
      - Vanderbilt University School of Medicine
      - Vanderbilt University Medical Center            
keywords:
  - Cost-Effectiveness Analysis
  - Microsimulation
  - Discrete Event Simulation
  - Markov Cohort Models
abstract: |
  This study outlines a methodological framework for joint modeling of Disability- and Quality-Adjusted Life Year outcomes. Our primary focus is on how transition matrices and state occupancy payoffs in discrete-time Markov cohort models can be structured to calculate years of life lost to disability (YLD) and years of life lost to premature death (YLL), in addition to quality-adjusted life year (QALY) outcomes. We also demonstrate how our modeling framework extends directly to microsimulation and (in part) to continuous time discrete event simulation (DES) models. In a tutorial application, we use our joing modeling framework to construct a discrete time Markov cohort natural history model for cardiovascular disease that estimates DALY and QALY outcomes for any country, region, or setting represented in the 2020 Global Burden of Disease data.
plain-language-summary: |
  Structuring Markov Models for Multidimensional Health Outcomes
key-points:
  - Key Point 1
  - Key Point 2
date: last-modified
bibliography: references.bib
citation:
  container-title: Citation title
number-sections: true
editor_options: 
  chunk_output_type: console
prefer-html: true  
---

## Introduction

```{r}
#| echo: false
#| message: false
#| warning: false
library(tidyverse)
library(MASS)
# library(Matrix)
library(expm)
library(knitr)
library(kableExtra)
options(scipen = 5) 
transpose <- purrr::transpose
select <- dplyr::select
#quarto preview index.qmd --to html --no-watch-inputs --no-browse
```

Disability-adjusted life years (DALYs) measure disease burden in a population. Conceptualized in the Global Burden of Disease (GBD) study [@Murray1997], DALYs quantify the total sum of years of life lost due to disability attributable to a disease (YLD), plus years of life lost to premature mortality from the disease (YLL; i.e., DALY = YLD + YLL).

In addition to their role in describing levels and trends in disease burdens worldwide, DALYs are a primary health outcome in evaluations of health interventions in low- and middle-income countries (LMICs). In these settings, resource allocation decisions are guided by modeled assessments of the incremental costs per DALY averted under alternative (often competing) strategies to improve population health.[^1]

[^1]: The adoption of DALYs over other common health outcomes in health economics (e.g., quality-adjusted life years, or QALYs) stems from several practical and theoretical considerations. See @Feng2020 and @Wilkinson2016 for futher discussion.

Despite the prominent role of DALYs in global health policy, scant methodological guidance is available for adapting and/or structuring decision analytic models for DALY outcomes. This methodological gap has its roots in health economics education, where textbooks and training exercises focus almost exclusively on Quality-Adjusted Life Year (QALY) outcomes---the primary health outcome used for health technology assessments (HTAs) and policy decisionmaking in high-income countries (HICs). DALYs differ from QALYs in important and model-relevant respects, including the use of reference life tables to calculate YLLs and standardized disability weights to calculate YLDs.[^2] To the extent DALY-specific modeling considerations are taught, they are often considered in isolation and without a firm methodological grounding in *how* one might structure a model to measure DALY outcomes.

[^2]: In contrast, QALYs are calculated based on utility weights derived from general and patient surveys. See @Feng2020 and @Wilkinson2016 for futher discussion.

As a consequence, and in practice, health economic applications often resort to shortcuts and other "hacks" for calculating DALYs. For example, practitioners may simply estimate a "QALY-like" DALY that is based on a diseased state occupancy payoff of one minus the disability weight. Other approaches define a diseased-state payoff using the disability weight as an estimate of YLDs, and accumulate person-years in an absorbing death state (due to disease) as an estimate of YLLs. As this study will show, these shortcuts do not provide an accurate representation of DALY levels in a population.

This tutorial outlines a framework for direct incorporation of DALY outcomes in common decision modeling environments. Our primary focus is on discrete-time Markov cohort models---however, our framework extends directly to microsimulation and is also easily adapted for continuous time discrete event simulation (DES) models. As such, our study provides a comprehensive roadmap for incorporating DALY outcomes into common decision modeling frameworks.

To maintain consistency within the literature, our tutorial builds on an existing didactic disease progression model [@alarid2023introductory]. The underlying discrete time Markov cohort model is time homogeneous---that is, transition probabilities do not vary as a function of age/time in model. However, the methods and code provided are easily adapted for time inhomogenous models. Finally, recognizing the wide spectrum of experience and programming comfort level among those constructing DALY-based models, we demonstrate our approach in both R and Microsoft Excel. 

## Background {#sec-background}

DALYs are calculated from two components. First, conditions are assigned disability weights ($D$) ranging from zero to one, with zero representing the absence of the condition and one representing the highest burden a condition can inflict, equivocal to death. Years lost to disability (YLD) is defined as the disability weight multiplied by the number of years a person lives with the condition ($L$):

$$
YLD(L) = D \cdot L
$$ {#eq-yld1} 

The impact of disease on mortality is quantified using years of life lost to disease (YLL), which is based on remaining life expectancy $Ex(a)$ at the age of premature death from the disease ($a$). 

$$
YLL(a)= Ex(a)
$$ {#eq-yll1} .

DALYs are the sum of the two components:

$$
DALY(L,a) = YLD(L) + YLL(a)
$$ {#eq-daly}

In the original GBD study, age-weighting and time discounting practices were applied to DALY calculations [@Murray1997]. These methods respectively weighted the burden of illness more during adulthood than early childhood and old age, and valued present health over future years of illness by discounting YLD and YLL measures by 3% per year. From 2010 onwards, both practices were discontinued to make the DALY a more descriptive measure [@who2013methods].

While the GBD no longer uses age and time discounting for the purposes of documenting disease burdens worldwide, the World Health Organization's Choosing Interventions that are Cost-Effective (WHO-CHOICE) program recommends consideration of time discounting of health outcomes [@murray2020; @bertram2021]. We therefore adopt the WHO-CHOICE recommendation and include continuous-time discounting in our DALY modeling approach.[^7]

[^7]: Practitioners who do not wish to discount DALY outcomes can simply set the annual discount rate $r$ to zero. In addition, our approach differentiates from common practice in the use of a continuous-time discount factor (i.e., $\frac{1}{r}(1-e^{rt})$), rather than a discrete-time discount factor (i.e., $1/(1+r)^t$). We do so to maintain consistency with the original GBD equations---though an approach based on discrete-time discounting could be used and will yield broadly similar results. 

For an annual discount rate $r$, and age age $a$, the equation for YLDs is,

$$
YLD(a,L) = D  \left ( \frac{1}{r}\left(1-e^{-r(L+a) }\right) \right ).
$$ {#eq-yld}

Similarly, YLLs are calculated as,

$$
YLL(a)= \frac{1}{r}\left(1-e^{-r Ex(a)}\right).
$$ {#eq-yll} 

### Reference Life Expectancy

While the creation of the DALY measure was an important step in global health research, it has received scrutiny due to its inherent assumptions and value judgements. For example, calculating YLLs requires the use of a reference life table that provides an estimate of ...

## Structuring a Discrete Time Markov Model for DALY Outcomes

This section outlines a process for structuring a discrete time Markov cohort model to estimate DALY outcomes. To demonstrate our method, we build on a progressive disease model in which healthy individuals develop a disease with two health states ("Sick" and "Sicker") [@alarid2023introductory]. Individuals can also transition to an absorbing death state due to causes unrelated to the disease (i.e., "background" mortality), or due to disease-specific causes. In addition, the model structure is homogeneous (i.e., transition rates do not vary as a function of time). This is a simplification to distill model complexity down to only those components needed to demonstrate our DALY approach---and our replication code is structured in such a way as to easily incorporate transition rates that are a function of age/time in model. 

We will structure our model to consider outcomes under four different strategies:

- A **Standard of Care** strategy based on the baseline model parameters.
- **Strategy A**,  which improves the quality of life among individuals with the disease, but does not affect disease progression.
- **Strategy B**, which reduces the rate of progression from Sick to Sicker by 40%.
- **Composite Strategy AB**, which jointly implements strategies A and B. 
 
A state transition diagram is shown in @fig-model1, and key model parameters are summarized ...

![State transition diagram for progressive disease model](images/state-transition-diagram-1.svg){#fig-model1}

```{r setup}
library(tidyverse)
library(MASS)
library(expm)
library(knitr)
library(kableExtra)
options(scipen = 5) 
transpose <- purrr::transpose
select <- dplyr::select
options(knitr.kable.NA = '')

gen_wcc <- function (n_cycles, method = c("Simpson1/3", "half-cycle", "none")) 
{
    if (n_cycles <= 0) {
        stop("Number of cycles should be positive")
    }
    method <- match.arg(method)
    n_cycles <- as.integer(n_cycles)
    if (method == "Simpson1/3") {
        v_cycles <- seq(1, n_cycles + 1)
        v_wcc <- ((v_cycles%%2) == 0) * (2/3) + ((v_cycles%%2) != 
                                                     0) * (4/3)
        v_wcc[1] <- v_wcc[n_cycles + 1] <- 1/3
    }
    if (method == "half-cycle") {
        v_wcc <- rep(1, n_cycles + 1)
        v_wcc[1] <- v_wcc[n_cycles + 1] <- 0.5
    }
    if (method == "none") {
        v_wcc <- rep(1, n_cycles + 1)
    }
    return(v_wcc)
}
```

```{r parameterize}
params_ <- list(
    # Treatment Strategies
    v_tx_names = c("SoC","A","B","AB"),      # treatment names
    n_tx = 4, # number of treatment strategies
    
    cycle_correction = "Simpson1/3",
    
    v_tr_names = c("H","S1","S2"), # transient health states
    v_ab_names = c("DOC","DS"), # absorbing health states
    n_states = 5, # total number of health states
    
    horizon = 200,    # model time horizon (in years)  
    r_v_disc_h  = 0.03,     # annual discount rate for health outcomes
    r_v_disc_c = 0.03,     # annual discount rate for cost outcomes
    Delta_t = 1,      # time step (1 = yearly, 1/12 = monthly, etc.)
    age0 = 25,         # age at baseline
    v_s0T = c(1,0,0,0,0), # initial state occupancy  
                      # c(1,0,0,0,0) means the modeled cohort starts off healthy
    
    r_HS1 = 0.15,   # disease onset rate
    r_S1H = 0.5,    # recovery rate
    r_S1S2 = 0.105,   # disease progression rate
    r_HD = 0.002,    # background mortality rate
    
    hr_S1 = 3.0,     # hazard rate of disease-related death from S1 state
    hr_S2 = 10.0,    # hazard rate of disease-related death from S1 state
    
    u_S1 = 0.75,       # Sick utility weight
    u_S2 = 0.5,        # Sicker utility weight
    u_D = 0,           # Death utility weight
    u_H = 1,           # Healthy utility weight
    
    dw_S1 = 0.2,      # Sick disability weight
    dw_S2 = 0.4,       # Sicker disability weight
    
    c_H = 2000,   # annual cost of healthy
    c_S1 = 4000,  # annual cost of S1
    c_S2 = 15000, # annual cost of S2
    c_D = 0, # annual cost of death

    c_trtA = 12000, # cost of treatment A
    u_trtA = 0.95, # utility weight for treatment A (S1 state)
    dw_trtA = 0.08,    # Disability weight for sick under treatment A
    
    c_trtB = 12000, # cost of treatment B
    hr_S1S2_trtB = 0.6, # reduction in rate of disease progression 
    
    hr_treat = 0.85,  # Hazard Ratio for Treatment Strategy
    hr_prevent = 0.9, # Hazard Ratio for Prevention Strategy

    df_ExR =  # Reference life table from GBD
          tibble::tribble(
              ~Age, ~Life.Expectancy,
              0L,       88.8718951,
              1L,      88.00051053,
              5L,      84.03008056,
              10L,      79.04633476,
              15L,       74.0665492,
              20L,      69.10756792,
              25L,      64.14930031,
              30L,       59.1962771,
              35L,      54.25261364,
              40L,      49.31739311,
              45L,      44.43332057,
              50L,      39.63473787,
              55L,      34.91488095,
              60L,      30.25343822,
              65L,      25.68089534,
              70L,      21.28820012,
              75L,      17.10351469,
              80L,      13.23872477,
              85L,      9.990181244,
              90L,      7.617724915,
              95L,      5.922359078
          )
)

params <- 
    with(params_,{
        modifyList(params_,list(
            v_names_states = c(v_tr_names, v_ab_names), # health state names
            omega = horizon/Delta_t,  # Total number of cycles
            r_v_disc_h_Delta_t = r_v_disc_h * Delta_t,  # Cycle discount rate: health outcomes
            r_v_disc_c_Delta_t = r_v_disc_c * Delta_t,  # Cycle discount rate: cost outcomes
            ages = (0:(horizon/Delta_t))*Delta_t + age0,  # Age in each cycle
             # Approximation function for reference life table life expectancies:
            f_ExR = function(x) pmax(0,unname(Hmisc::approxExtrap(df_ExR$Age, df_ExR$Life.Expectancy,xout = x)$y))
        ))
    })

params$ages_trace <- params$ages
params$ages <- params$ages[-length(params$ages)]

v_disc_h =  # Continuous time discounting
  exp(-params$r_v_disc_h_Delta_t  * 0:(params$omega))
# v_disc_h =  # Discrete time discounting
#   with(params,1 / (( 1 + (r_v_disc_h * Delta_t)) ^ (0 : omega)))
v_disc_c = 
  exp(-params$r_v_disc_c_Delta_t  * 0:(params$omega))
```

### Transition Matrices


### Scratch

Modeling DALYs requires us to track deaths due to disease. This is difficult in a model structured based on @fig-model1 because the absorbing death state includes individuals who transition from the non-diseased state. Our first step, then, is to redefine the health states to include two absorbing death states: death from other causes, and death from disease (@fig-model2):[^othcause]

[^othcause]: In this example, disease-specific death rates are goverened by a hazard ratio applied to the background mortality rate. Because we are operating on the rate scale, we can separate out disease-related deaths from other-cause mortality by simply taking a difference in the rates. Other applications for prevalent conditions with high death rates, however, may require us to construct a cause-deleted life table to obtain background mortality rates that net out deaths from the modeled disease.

![State transition diagram with two absorbing death states](images/state-transition-diagram-2.svg){#fig-model2}




```{r transition-matrices}
fn_r_HD <- function(age) {
  # Access r_HD from the parent frame where this function is called
  r_HD <- get("r_HD", envir = parent.frame())
  r_HD
}

fn_r_HS1 <- function(age) {
  # Access r_HD from the parent frame where this function is called
  r_HS1 <- get("r_HS1", envir = parent.frame())
  r_HS1
}

fn_r_S1H <- function(age) {
  # Access from the parent frame where this function is called
  r_S1H <- get("r_S1H", envir = parent.frame())
  r_S1H
}

fn_r_S1S2 <- function(age) {
  # Access  from the parent frame where this function is called
  r_S1S2 <- get("r_S1S2", envir = parent.frame())
  r_S1S2
}

params1 <- with(params,modifyList(params,list(
    # Natural History Transition Rate Matrix
    m_R = 
      ages %>% map(~({
        mR_SoC = 
          matrix(c(
          -(fn_r_HD(.x)+fn_r_HS1(.x)), fn_r_HS1(.x), 0, fn_r_HD(.x), 0,
          fn_r_S1H(.x),-(fn_r_S1H(.x) + fn_r_S1S2(.x) + fn_r_HD(.x) + hr_S1 * fn_r_HD(.x) - fn_r_HD(.x)),fn_r_S1S2(.x),fn_r_HD(.x),hr_S1 * fn_r_HD(.x) - fn_r_HD(.x),
          0,0,-(fn_r_HD(.x) + hr_S2 * fn_r_HD(.x) - fn_r_HD(.x)),fn_r_HD(.x),hr_S2 * fn_r_HD(.x) - fn_r_HD(.x),
          0,0,0,0,0,          
          0,0,0,0,0),
          nrow = n_states, 
          ncol = n_states,
          byrow=TRUE, 
          dimnames = list(c(v_tr_names,v_ab_names),
                          c(v_tr_names,v_ab_names)
          ))
        
        mR_A = 
          matrix(c(
          -(fn_r_HD(.x)+fn_r_HS1(.x)), fn_r_HS1(.x), 0, fn_r_HD(.x), 0,
          fn_r_S1H(.x),-(fn_r_S1H(.x) + fn_r_S1S2(.x) + fn_r_HD(.x) + hr_S1 * fn_r_HD(.x) - fn_r_HD(.x)),fn_r_S1S2(.x),fn_r_HD(.x),hr_S1 * fn_r_HD(.x) - fn_r_HD(.x),
          0,0,-(fn_r_HD(.x) + hr_S2 * fn_r_HD(.x) - fn_r_HD(.x)),fn_r_HD(.x),hr_S2 * fn_r_HD(.x) - fn_r_HD(.x),
          0,0,0,0,0,          
          0,0,0,0,0),
          nrow = n_states, 
          ncol = n_states,
          byrow=TRUE, 
          dimnames = list(c(v_tr_names,v_ab_names),
                          c(v_tr_names,v_ab_names)
          ))
        
        mR_B = 
          matrix(c(
          -(fn_r_HD(.x)+fn_r_HS1(.x)), fn_r_HS1(.x), 0, fn_r_HD(.x), 0,
          fn_r_S1H(.x),-(fn_r_S1H(.x) + hr_S1S2_trtB * fn_r_S1S2(.x) + fn_r_HD(.x) + hr_S1 * fn_r_HD(.x) - fn_r_HD(.x)),hr_S1S2_trtB *  fn_r_S1S2(.x),fn_r_HD(.x),hr_S1 * fn_r_HD(.x) - fn_r_HD(.x),
          0,0,-(fn_r_HD(.x) + hr_S2 * fn_r_HD(.x) - fn_r_HD(.x)),fn_r_HD(.x),hr_S2 * fn_r_HD(.x) - fn_r_HD(.x),
          0,0,0,0,0,          
          0,0,0,0,0),
          nrow = n_states, 
          ncol = n_states,
          byrow=TRUE, 
          dimnames = list(c(v_tr_names,v_ab_names),
                          c(v_tr_names,v_ab_names)
          ))
        
        mR_AB = 
          matrix(c(
          -(fn_r_HD(.x)+fn_r_HS1(.x)), fn_r_HS1(.x), 0, fn_r_HD(.x), 0,
          fn_r_S1H(.x),-(fn_r_S1H(.x) + hr_S1S2_trtB *  fn_r_S1S2(.x) + fn_r_HD(.x) + hr_S1 * fn_r_HD(.x) - fn_r_HD(.x)),hr_S1S2_trtB * fn_r_S1S2(.x),fn_r_HD(.x),hr_S1 * fn_r_HD(.x) - fn_r_HD(.x),
          0,0,-(fn_r_HD(.x) + hr_S2 * fn_r_HD(.x) - fn_r_HD(.x)),fn_r_HD(.x),hr_S2 * fn_r_HD(.x) - fn_r_HD(.x),
          0,0,0,0,0,          
          0,0,0,0,0),
          nrow = n_states, 
          ncol = n_states,
          byrow=TRUE, 
          dimnames = list(c(v_tr_names,v_ab_names),
                          c(v_tr_names,v_ab_names)
          ))
        
        array(c(as.vector(mR_SoC),
                as.vector(mR_A), 
                as.vector(mR_B),
                as.vector(mR_AB)), 
              dim = c(length(v_tr_names)+ length(v_ab_names),length(v_tr_names)+ length(v_ab_names),length(v_tx_names)),
          dimnames = list(c(v_tr_names,v_ab_names),c(v_tr_names,v_ab_names),v_tx_names)) %>% 
            apply(.,3,function(x) x, simplify=FALSE) 
        
      }))
    )))

params1 <- with(params1,modifyList(params1,list(
    m_P = m_R %>% transpose() %>% map(~({
      mR_ = .x
      mR_ %>% map(~({
              expm(.x * Delta_t)
         }))
      }))
)))

```

```{r trace}
trace1 <- 
    with(params1, {
        m_P %>% map( ~ ({
            P = .x
            occ <- v_s0T
            P %>% map(~({
              occ <<- occ %*% .x
            })) %>% 
            map(~(data.frame(.x))) %>% 
            bind_rows()
        }))
    })  %>% 
    map(~({
        tmp = .x[1,]
        tmp[1,] = params$v_s0T
        tmp = rbind(tmp,.x)
    }))
```


```{r}
# Life Expectancy (Non-Discounted)
le_ = with(params1,(matrix(c(1,
              1 ,
              1,
              0,
              0)*Delta_t,
            dimnames = list(c(
                c(v_tr_names,v_ab_names)
            ), c("DW")))
))

LEt <- trace1 %>% map( ~ ({
    tmp = as.matrix(.x) %*% le_
    tmp 
}))

LE = LEt %>% map(~sum(.x * gen_wcc(params1$omega, method = params1$cycle_correction))) 

# QALYs
qaly_ = with(params1,(matrix(c(u_H,
              u_S1 ,
              u_S2,
              u_D,
              u_D) * Delta_t,
            dimnames = list(c(
                c(v_tr_names,v_ab_names)
            ), c("UW")))
))
qaly_ <- 
  with(params1,{
    v_tx_names %>% map(~({
        if (.x=="A" | .x=="AB") {
          tmp_ <- qaly_
          tmp_[2,1] = u_trtA * Delta_t
          tmp_
      } else qaly_
    }))
  })

QALYt <- trace1 %>% map2(.,qaly_, ~ ({
    tmp = as.matrix(.x) %*% .y
    tmp 
}))

QALY = QALYt %>% map(~sum(.x * v_disc_h * gen_wcc(params1$omega, method = params1$cycle_correction))) 

# YLD
yld_ = with(params1,(matrix(c(0,
              dw_S1 * Delta_t * (1/r_v_disc_h_Delta_t) * (1 - exp(-r_v_disc_h_Delta_t)) ,
              dw_S2 * Delta_t * (1/r_v_disc_h_Delta_t) * (1 - exp(-r_v_disc_h_Delta_t)),
              0,
              0),
            dimnames = list(c(
                c(v_tr_names,v_ab_names)
            ), c("DW")))
))
yld_ <- 
  with(params1,{
    v_tx_names %>% map(~({
        if (.x=="A" | .x=="AB") {
          tmp_ <- yld_
          tmp_[2,1] = dw_trtA * Delta_t * (1/r_v_disc_h_Delta_t) * (1 - exp(-r_v_disc_h_Delta_t))
          tmp_
      } else yld_
    }))
  })

YLDt <- trace1 %>% map2(.,yld_, ~ ({
    tmp = as.matrix(.x) %*% .y
    tmp 
}))

YLD = YLDt %>% map(~sum(.x*  v_disc_h * gen_wcc(params1$omega, method = params1$cycle_correction)))

# YLL

new_deaths_from_disease <- 
    map(trace1,~({
        c(0,diff(.x[,"DS"]))
    })) 
   
remaining_life_expectancy <- 
    with(params1,(1/r_v_disc_h) * (1 - exp(-r_v_disc_h * f_ExR(ages_trace))))
    
YLLt <- 
    new_deaths_from_disease %>% map(~(.x * remaining_life_expectancy ))

YLL <- 
    YLLt %>% map(~(sum(.x * v_disc_h * gen_wcc(params1$omega,method = params1$cycle_correction))))

DALY <- 
    map2(YLL,YLD,~(.x + .y))

# QALY-Like DALY
qaly_daly_ = with(params1,(matrix(c(0,
              dw_S1 * Delta_t * (1/r_v_disc_h_Delta_t) * (1 - exp(-r_v_disc_h_Delta_t)) ,
              dw_S2 * Delta_t * (1/r_v_disc_h_Delta_t) * (1 - exp(-r_v_disc_h_Delta_t)),
              0,
              1) * Delta_t,
            dimnames = list(c(
                c(v_tr_names,v_ab_names)
            ), c("UW")))
))
qaly_daly_ <- 
  with(params1,{
    v_tx_names %>% map(~({
        if (.x=="A" | .x=="AB") {
          tmp_ <- qaly_daly_
          tmp_[2,1] = dw_trtA * Delta_t * (1/r_v_disc_h_Delta_t) * (1 - exp(-r_v_disc_h_Delta_t))
          tmp_
      } else qaly_daly_
    }))
  })

QALY_DALYt <- trace1 %>% map2(.,qaly_daly_, ~ ({
    tmp = as.matrix(.x) %*% .y
    tmp 
}))

QALY_DALY = QALY_DALYt %>% map(~sum(.x * v_disc_h * gen_wcc(params1$omega, method = params1$cycle_correction))) 

# Costs
cost_ = with(params1,(matrix(c(c_H,
              c_S1 ,
              c_S2,
              c_D,
              c_D)*Delta_t,
            dimnames = list(c(
                c(v_tr_names,v_ab_names)
            ), c("COST")))
))
cost_ <-
  with(params1, {
    v_tx_names %>% map( ~ ({
      if (.x == "A") {
        tmp_ <- cost_
        tmp_["S1", 1] = (c_S1 + c_trtA)*Delta_t
        tmp_["S2", 1] = (c_S2 + c_trtA)*Delta_t
        tmp_
      } else if (.x == "B") {
        tmp_ <- cost_
        tmp_["S1", 1] = (c_S1 + c_trtB)*Delta_t
        tmp_["S2", 1] = (c_S2 + c_trtB)*Delta_t
        tmp_
      } else if (.x == "AB") {
        tmp_ <- cost_
        tmp_["S1", 1] = (c_S1 + c_trtA + c_trtB)*Delta_t
        tmp_["S2", 1] = (c_S2 + c_trtA + c_trtB)*Delta_t
        tmp_
      } else cost_
    }))
  }) %>% 
  set_names(params1$v_tx_names)

COSTt <- trace1 %>% map2(.,cost_, ~ ({
    tmp = as.matrix(.x) %*% .y
    tmp 
}))

COST = COSTt %>% map(~sum(.x * v_disc_c * gen_wcc(params1$omega, method = params1$cycle_correction))) 

result1 <- cbind(LE, QALY, YLD, YLL, DALY, QALY_DALY, COST) %>%
  as.data.frame() %>%
  mutate_all( ~ as.numeric(.))  %>%
  rownames_to_column(var = "strategy") %>%
  mutate(approach = "Markov Trace") %>% 
  dplyr::select(approach, strategy, LE, QALY,YLD, YLL, DALY, QALY_DALY, COST) 

result1 %>% 
    kable(digits = 3, col.names = c("Approach","Scenario","Life Expectancy (Model)","QALYs","YLDs","YLLs","DALYs","QALY-like DALY","Costs")) 
```

```{r}
result1 %>% 
  select(strategy,QALY,COST) %>% 
  arrange(COST) %>% 
  mutate(iQALY = c(0,diff(QALY)),
         iCOST = c(0,diff(COST))) %>% 
  mutate(icer = iCOST / iQALY) %>% 
  filter(is.na(icer) | icer>0) %>% 
  arrange(COST) %>% 
  mutate(iQALY = c(NA,diff(QALY)),
         iCOST = c(NA,diff(COST))) %>% 
  mutate(icer = iCOST / iQALY) %>% 
  bind_rows(result1 %>% 
  select(strategy,QALY,COST) %>% filter(strategy=="A")) %>% 
  kable() 
  
```

```{r}
result1 %>% 
  select(strategy,DALY,COST) %>% 
  arrange(COST) %>% 
  mutate(iDALY = c(0,pmax(0,-diff(DALY))),
         iCOST = c(0,diff(COST))) %>% 
  mutate(icer = iCOST / iDALY) %>% 
  filter(is.na(icer) | icer>0) %>% 
  filter(!is.infinite(icer)) %>% 
  arrange(COST) %>% 
  mutate(iDALY = c(NA,pmax(0,-diff(DALY))),
         iCOST = c(NA,diff(COST))) %>% 
  mutate(icer = iCOST / iDALY) %>% 
  bind_rows(result1 %>% 
  select(strategy,DALY,COST) %>% filter(strategy=="A")) %>% 
  kable()
```

```{r}
result1 %>% 
  select(strategy,QALY_DALY,COST) %>% 
  arrange(COST) %>% 
  mutate(iDALY = c(0,pmax(0,-diff(QALY_DALY))),
         iCOST = c(0,diff(COST))) %>% 
  mutate(icer = iCOST / iDALY) %>% 
  filter(is.na(icer) | icer>0) %>% 
  filter(!is.infinite(icer)) %>% 
  arrange(COST) %>% 
  mutate(iDALY = c(NA,pmax(0,-diff(QALY_DALY))),
         iCOST = c(NA,diff(COST))) %>% 
  mutate(icer = iCOST / iDALY) %>% 
  bind_rows(result1 %>% 
  select(strategy,QALY_DALY,COST) %>% filter(strategy=="A")) %>% 
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "condensed")) #%>% 
  #save_kable("images/test.png")
```

```{r}

```

## Conclusion

## References {.unnumbered}

:::{#refs}

:::